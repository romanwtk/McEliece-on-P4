% !TeX encoding = UTF-8
% !TeX program = pdflatex
% !BIB program = bibtex

%%% Um einen Artikel auf deutsch zu schreiben, genügt es die Klasse ohne
%%% Parameter zu laden.
\documentclass[utf8, biblatex]{lni}
%%% To write an article in English, please use the option ``english'' in order
%%% to get the correct hyphenation patterns and terms.
%%% \documentclass[english]{class}
%%

\usepackage{algorithm}
\usepackage{algpseudocode}

\bibliography{literature}

\begin{document}
%%% Mehrere Autoren werden durch \and voneinander getrennt.
%%% Die Fußnote enthält die Adresse sowie eine E-Mail-Adresse.
%%% Das optionale Argument (sofern angegeben) wird für die Kopfzeile verwendet.
\title[Ein Kurztitel]{Implementierung des McEliece-Kryptosystems auf P4-programmierbaren Switches}
%%%\subtitle{Untertitel / Subtitle} % if needed
\author[Roman Wetenkamp]
{Roman Wetenkamp\footnote{Duale Hochschule Baden-Württemberg Mannheim\\ \email{s200376@student.dhbw-mannheim.de}}}
\startpage{1} % Beginn der Seitenzählung für diesen Beitrag / Start page
\editor{} % Names of Editors
\booktitle{SKILL 2023} % Name of book title
\yearofpublication{2023}
%%%\lnidoi{18.18420/provided-by-editor-02} % if known
\maketitle
\begin{abstract}
This is a brief overview of the paper, which should be 70 to 150 words long and
include the most relevant points. This has to be a single paragraph.
\end{abstract}
\begin{keywords}
McEliece \and Code-basierte Kryptography \and Programmierbare Switches
\end{keywords}
%%% Beginn des Artikeltexts
\section{Einführung}
Seitdem die Aussicht auf einen Quantencomputer, der bisher in der Kryptographie verwendete Probleme wie jenes des \textit{diskreten Logarithmus} oder der \textit{Primfaktorzerlegung} für große Zahlen deutlich effizienter brechen kann als Computer mit herkömmlichen Prozessoren, immer realistischer wird, nimmt die Forschung zur \textit{Post-Quanten-Kryptographie} stetig zu. Neben Verfahren, die auf Gittern oder multivariaten Polynomen basieren, gelten auch einige \textit{code-basierte Verfahren} als quantensicher und sind somit beispielsweise Teil eines Standardisierungsprozesses des National Institute of Standards and Technology (NIST) in den USA \cite{NISTPQC3}. Diese Kryptosysteme nutzen lineare, fehlerkorrigierende Codes wie \textit{verallgemeinerte Reed-Solomon-Codes} oder \textit{Goppa-Codes} und deren \textit{Dekodierproblem} aus, das darin besteht, dass es hinreichend schwierig ist, von einem durch eine permutierte und verwürfelte Generatormatrix erzeugten Codewort auf die ursprünglich verwendete Generatormatrix zurückzuschließen \cite{Berlekamp1978}. Eines der ersten und bekanntesten code-basierten Kryptosysteme ist jenes von \textsc{McEliece} \cite{McEliece1978}, dessen Implementierung die erste Hauptkomponente dieser Arbeit darstellt.\\
Die zweite Komponente ergibt sich durch \textit{programmierbare Switches}. Während Verschlüsselungsoperationen von Netzwerkdatenpaketen typischerweise im Endgerät (beispielsweise einem Server oder einem Client) ausgeführt werden, ergibt sich mit programmierbaren Switches eine Möglichkeit, die Daten im Switch zu verschlüsseln. \\Diese Arbeit widmet sich der Fragestellung, inwiefern das \textsc{McEliece}-Kryptosystem in programmierbaren Switches implementiert werden kann. Zunächst werden in Abschnitt \ref{S2} die Hintergründe beider Technologien erläutert, bevor in Abschnitt \ref{S3} die Umsetzung in der Domänen-spezifischen und nicht Turing-vollständigen Sprache \textit{P4} \cite{P4} erfolgt. Die Ergebnisse werden abschließend anhand einer Switch-Emulation reflektiert und zusammengefasst.
\section{Ausgangslage und Beitrag}
Fundament dieser Arbeit in kryptographischer Hinsicht sind die Darstellung des \textsc{McEliece}-Kryptosystems in \cite{McEliece1978}, die Definition von \textit{Goppa}-Codes in \cite{Berlekamp1973} und die Implementierung des \textsc{McEliece}-Kryptosystems basierend auf quasi-zyklischen MDPC-Codes in \cite{Maurich2015}, die auf \cite{Misoczki2013} basiert. Die Idee, Ver- und Entschlüsselung auf programmierbaren Switches durchzuführen, wird in \cite{Chen2020} anhand des AES-Verfahrens dargestellt. \cite{AlSabeh2022} liefert eine Übersicht über bisherige Arbeiten zu diesem Ansatz, die keine Verfahren enthält, die Teil des \textit{Post Quantum Cryptography}-Standardisierungsprozesses sind. \\\\
Diese Arbeit entwirft eine Implementierung des ursprünglichen \textsc{McEliece}-Kryptosystems in der Sprache \textit{P4}, evaluiert jene anhand der Switch-Emulation \textit{bmv2} und diskutiert Limitationen neben der praktischen Umsetzbarkeit des Entwurfs.
\section{Hintergründe}
\subsection{\textsc{McEliece}-Kryptosystem}
Das \textsc{McEliece}-Kryptosystem ist eine Blockchiffre auf der Basis von linearen fehlerkorrigierenden Codes, wobei ursprünglich \textit{Goppa}-Codes, in aktuellen Verfahren meist quasi-zyklische MDPC-Codes vorgeschlagen werden \cite{McEliece1978} \cite{Misoczki2013}. \\\\
Die zu einem gewählten $[n, k]$-Code gehörige Generatormatrix wird als $G$ und die Paritätsprüfmatrix als $H$ bezeichnet. Dann ist der öffentliche Schlüssel $K_{pub}$ definiert durch das Matrixprodukt aus einer nicht-singulären und dichten $k \times k$-Verwürfelungsmatrix $S$, der Generatormatrix $G$ und einer $n \times n$-Permutationsmatrix $P$, also $K_{pub} = S \cdot G \cdot P$ \cite[S. 114]{McEliece1978}. \\\\
Die Verschlüsselungsoperation erfolgt nun, in dem jeder Klartextblock der Länge $k$ mit $K_{pub}$ multipliziert und ein zufälliger Störvektor $z$ mit Länge $n$ und Gewicht $t$ addiert wird \cite{McEliece1978}. 
\begin{algorithm}[h!]
\caption{Verschlüsselungsalgorithmus des \textsc{McEliece}-Kryptosystems (nach \parencite{McEliece1978})} \label{McElieceEnc}
\begin{algorithmic}[1]
\Require $K_{pub}$, Eingabedaten $m$ mit $l$ Komponenten aus $\mathbb{F}_{2^f}$
\State Teile $m$ in Blöcke der Länge $k$ (ggf. mit Nullen auffüllen)
\For{$u$ in $m[]$}
	\State Wähle zufälligen Störvektor $z$ mit Länge $n$ und Gewicht $t$
	\State $x_u \gets u \cdot K_{pub} + z$
\EndFor \\
\Return $x$
\end{algorithmic}
\end{algorithm}\\
\printbibliography
\end{document}
